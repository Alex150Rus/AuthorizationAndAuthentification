/* pasport.js - самый популярный фрэймворк для реализации авторизациии, аутентификации в
Node.JS проектах. В нём ипользуется несколько палезных паттернов, среди которых Стратегия.
Авторизация обычно реализовывается через сессию и куки. В NodeJS работа с сессиями происходит
не так как в PHP(хранятся в виде файлов в файловой системе) - в Node.JS может быть реализованно
по-разному. В одном милваре может хранится в виде файлов - в другом - в виде ключей в оперативной 
памяти. Но большинство подходов в Node.JS связано с тем, что сессии хранятся в опреативной памяти
Всё зависит от проекта.

Как сделать так, чтобы данные сохранялись в сессию? Для этого потребуется отдельная мидлвара - 
cookie-session, которая работает в сочитании с cookie-parser. На самом деле это мидлвары для экспресса

У паспорта также есть понятие middleware. Каждый вид реализуемой авторизации называется стратегией.
Сейчас их более 100 штук. Есть стратегии для локальной авторизации по логину и паролю, через сторонние
сервисы, с помощью токенов. 

Стратегия - это очень распространённый патерн проектирования. Все патерны на refactoring.guru
Устанавливаем сам паспорт и стратегию для него - способ авторизации, который будем использовать.
Мы будем испоользовать локальный способ по логину и паролю. npm i passport passport-local
если хотим авторизацию через facebook - устанавливаем passport-facebook

Чтобы начать использовать пасспорт нам нужен экспресс и само приложение.
*/

const express = require('express');
const bodyParser = require('body-parser');

const mongoose = require('mongoose');
mongoose.connect('mongodb://localhost/test', {useNewUrlParser: true});
const {User} = require('./models/index');
/*ставим на всякий случай, вдруг что-то нужно сохранить в сессии. Этот модуль, в целом,
для работоспособности паспорта не нужен. Просто лепим приложение, которое можно будет при
необходимости расширять.
*/
const cookieParser = require('cookie-parser');
const session = require('cookie-session');

const pasport = require('passport');
const LocalStrategy = require('passport-local');

//создаём приложение
const app = express();

//крепим необходимые мидлвары
// bodyParser обязателен и определяет в каком виде я буду передавать данные для аутентификации.
// в нашем случае это json, но может быть urlEncoded и другие - зависит от целей
app.use(bodyParser.json());
app.use(cookieParser());
app.use(session({ keys: ['secret']}));

// теперь подключим к нашему приложению всё что касается паспорта. Работа с паспортом зависит от вида
// используемой аутентификации и аутентификации. Есть виды авторизации, использующие сессию (сохранение
// состояния на сервере) и наоборот.

//используется всегда вне зависимости от вида авторизации
app.use(passport.initialize());
//используется только в случаях авторизации через сессию. Есди бы у нас была авторизация с токенами - нам
//бы эта строчка была не нужна
app.use(passport.session());

/*следующий шаг - конфигурация паспорта. Внутри него мы используем стратегию
функция done - это своеобразный callback, который сообщает результат авторизации
username и password по умолчанию должны отправляться с такими именами, но это можно настроить
В частности, в стратегию, в качестве параметра можно передать некий объект с названиями полей
*/
passport.use(new LocalStrategy(async (username, password, done) => {
  /* здесь мы должны описать логику работы с нашими пользователями: получать пользователя и сравнивать
  полученный пароль с имеющимся в базе паролем. 1) пробуем найти в базе пользователя по username
  - User.findOne({username}) - даёт объект MongoDb со всеми дополнительными методами и св-вами Mongo
  .lean() - превращает его в обычный JS объект.
  */
  const user = await User.findOne({username}).lean();
  if (user && user.password === password) { 
    //заменить на сравнение пароля с использованием хэша
    //в базе не будет храниться пароль. Будет храниться его хэш. В done - null, так как никакой ошибки
    //у нас нет. Второй параметр - объект нашего пользователя, полученного из базы. Здесь есть несколько важных
    //моментов. Во-первых, мы извлекаем пользователя целиком (и пароль, и хеш, и имя пользователя) и если его
    // передавать в явном виде как он есть - он полностью запишется в оперативную память. Поэтому нужно удалить из Юзера зна
    //чимую информацию.
    delete user.password; //удалить из пользователя всю значимую информацию.
    done(null, user) // user запишется в request.user
  } else {
    return done(null,false);
  }
}, {
  fieldNamePassword: 'psw',
  fieldNameUsername: 'user',
}));

/*Следующие два метода сокращают хранение пользователя в оперативной памяти. Использование
сессии может разделиться на несколько этапов: сессия когда пользователь прямо сейчас онлайн
и сессия когда пользователь ушёл (долговременное и кратковременное хранение сессии).
В рамках паспорта в кратковременное хранилище сессии записывают всего пользователя целиком, т.к.,
обычно, в приложении нужен весь пользователь, но для долговоременного хранения это не нужно, т.к,
быстро заполнится оперативная память и это скажется на пропускной способности приложения. Поэтому,
в рамках паспорта существуют два метода: serializeUser и deserialize user
*/

/* записывает какую-то часть юзера для долговременного хранения(чаще всего - id)
 а deserialiseUser - используется для того, чтобы из долговремменого хранилища сделать кратковременное
хранилище. Т.е. когда пользователь заходит на сайт и он ранее был авторизован, т.е мы смогли определить 
какая сессия этому пользователю принадлежит, в этот момент вызывается метод deserializeUser и мы должны
в нём из БД достать по id или другому полю в долговременном хранилище и восстановить полностью 
всю сессию пользователя.
*/
passport.serializeUser((user, done) => {
  //в методе done вызываем то поле, которое является у нашего пользователя id-шником
  done(null, user._id); //_id - mongoDb style
 });
 
 passport.deserializeUser(async (id, done) => {
   const user = await User.findById(id).lean();
   delete user.password; //удалить из пользователя всю значимую информацию.
   done(null, user); // здесь тоже должны не забыть удалить из юзера пароли и т.п.
 });

//дальше формируем обработчик роута для нашего экспресса, с помощью которого будет происходить авторизация
//(стратегия, дополнительные опции - редирект в случае успеха или неудачи авторизации). Для разных стратегий
//могут быть разные опции, но конкретно для нашей - successRedirect и failureRedirect
 const authHandler = passport.authenticate('local', {
  successRedirect: '/user',
  failureRedirect: '/auth'
 });

 //следующий этап - создание необходимых адресов
 app.post('/auth', authHandler);
 app.get('/auth', (request, response) => {
   //сделать форму авторизации
   response.send('ToDo: Login form');
 });

 //теперь нужно защитить роут, на который мы отправляем данные и
 //допустим есть роуты, которые доступны только после авторизации. Мы тоэе их должны защитить и
 //не давать доступ кому попало. Нужно просто взять мидлвару, которая будет проверять авторизован пользователь или нет

const mustBeAuthenticated = (request, resolve, next =>{
  //если авторизация прошла успешно
  if(request.user) {
    // то пропускаем юзера дальше с помощью метода next
    next();
  } else {
    response.redirect('/auth')
  }
});

app.all('user', mustBeAuthenticated);
app.all('user/*', mustBeAuthenticated);

app.get('/user', (request, response) => {
  response.send('User');
});

app.get('/user/settings', (request, response) => {
   response.send('User settings');
});

app.listen(8888);